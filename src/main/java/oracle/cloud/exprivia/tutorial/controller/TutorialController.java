package oracle.cloud.exprivia.tutorial.controller;

import oracle.cloud.exprivia.tutorial.model.Tutorial;
import oracle.cloud.exprivia.tutorial.repository.TutorialRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.server.ResponseStatusException;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;


/**
 * Controller per la gestione degli endpoint relativi ai tutorial.
 */
@RestController // This means that this class is a Controller
@RequestMapping(path="/api") // This means URL's start with /api (after Application path)
public class TutorialController {
    @Autowired // This means to get the bean called tutorialRepository
    // Which is auto-generated by Spring, we will use it to handle the data
    private TutorialRepository tutorialRepository;

    Logger log = LoggerFactory.getLogger(TutorialController.class);

    /**
     * API per ottenere tutti i `tutorials`, eventualmente filtrati per `title`
     * @param title (opzionale) titolo del tutorial che si vuole recuperare
     * @return una lista di {@link Tutorial}
     */
    @GetMapping("/tutorials")
    public ResponseEntity<List<Tutorial>> getAllTutorials(@RequestParam(name = "title", required = false) String title) {
        List<Tutorial> tutorials;
        log.info("GET /tutorials");
        if (title == null)
            // In questo caso assegno direttamente il risultato alla lista
            tutorials = tutorialRepository.findAll();
        else
            // In questo caso costriusco la lista usando forEach
//            tutorialRepository.findByTitleContaining(title).forEach(tutorials::add);
//        Equivalente al forEach (basta scrivere new ArrayList sopra in List<Tutorial> tutorials
            tutorials = new ArrayList<Tutorial>(tutorialRepository.findByTitleContaining(title));

        if (tutorials.isEmpty()) {
            // Nessun contenuto da ritornare
            return new ResponseEntity<>(HttpStatus.NO_CONTENT);
        }

        return new ResponseEntity<>(tutorials, HttpStatus.OK);
    }

    /**
     * Recupera tutti i tutorial pubblicati.
     *
     * @return Una lista di tutorial pubblicati, o uno stato HTTP 204 No Content se non ci sono tutorial pubblicati.
     */
    @GetMapping("/tutorials/getPublished")
    public ResponseEntity<List<Tutorial>> findByPublished() {
        log.info("Request GET /tutorials/getPublished");
        List<Tutorial> tutorials = tutorialRepository.findByPublished(true);

        if (tutorials.isEmpty()) {
            return new ResponseEntity<>(HttpStatus.NO_CONTENT);
        }

        return new ResponseEntity<>(tutorials, HttpStatus.OK);
    }

    /**
     * API per recuperare un tutorial a partire dal suo id
     * @param id    (Obbligatorio) ID del tutorial da recuperare
     * @return  un oggetto di tipo Tutorial
     */
    @GetMapping("/tutorials/{id}")
    public ResponseEntity<Tutorial> getTutorialById(@PathVariable("id") long id) {
        log.info("Request GET /tutorials/" + id);
        Tutorial tutorial = tutorialRepository.findById(id)
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND,
                        "Tutorial Not Found With Id = " + id));
        return new ResponseEntity<>(tutorial, HttpStatus.OK);
    }

    /**
     * Aggiunge un nuovo tutorial utilizzando i dati forniti nel corpo della richiesta.
     *
     * @param tutorial Il tutorial da aggiungere, fornito nel corpo della richiesta.
     * @return Un oggetto ResponseEntity contenente il tutorial appena creato e lo stato HTTP 201 Created.
     */
    @PostMapping(path = "/tutorial")
    public ResponseEntity<Tutorial> addTutorial(@RequestBody Tutorial tutorial) {
        log.info("Request POST /tutorial/");
        // Esegue la validazione e ottiene i valori validati per titolo, descrizione e stato di pubblicazione
        String title = validaTitolo(tutorial.getTitle());
        String description = validaDescription(tutorial.getDescription());
        Boolean published = validaPublished(tutorial.getPublished());

        // Crea il nuovo tutorial utilizzando i dati validati e lo salva nel repository
        Tutorial tutorialCreated = tutorialRepository.save(new Tutorial(title, description, published));

        // Restituisce un ResponseEntity con il tutorial appena creato e lo stato HTTP 201 Created
        return new ResponseEntity<>(tutorialCreated, HttpStatus.CREATED);
    }


    /**
     * API per la modifica di un tutorial. Occorre specificare in Path l'ID del tutorial
     * e nel payload i valori dell'oggetto che andranno a modificare quello già
     * presente sulla tabella.
     * @param id    (Obbligatorio) ID del tutorial da modificare
     * @param tutorialDaAggiornare  Oggetto {@link Tutorial}
     * @return  un oggetto di tipo {@link Tutorial}
     */
    @PutMapping("/tutorial/{id}")
    public ResponseEntity<Tutorial> updateTutorial(@PathVariable("id") Long id, @RequestBody Tutorial tutorialDaAggiornare) {
        log.info("Request PUT /tutorial/" + id);
        Tutorial tutorial = tutorialRepository.findById(id)
                .orElseThrow( ()-> new ResponseStatusException(HttpStatus.NOT_FOUND, "Tutorial non trovato con id " + id));

        String title = validaTitolo(tutorialDaAggiornare.getTitle());
        String description = validaDescription(tutorialDaAggiornare.getDescription());
        Boolean published = validaPublished(tutorialDaAggiornare.getPublished());

        // Aggiorna le proprietà del Tutorial con i valori del nuovo Tutorial ricevuto
        tutorial.setTitle(title);
        tutorial.setDescription(description);
        tutorial.setPublished(published);

        // Salva il Tutorial aggiornato nel repository
        return new ResponseEntity<>(tutorialRepository.save(tutorial),HttpStatus.OK);
    }

    /**
     * Cancella un tutorial utilizzando l'ID fornito.
     *
     * @param id (Obbligatorio) ID del tutorial da cancellare
     * @return Uno stato HTTP che indica il risultato dell'operazione.
     */
    @DeleteMapping(path="/tutorial/{id}")
    public ResponseEntity<HttpStatus> deleteTutorialById(@PathVariable("id") Long id) {
        log.info("Request DELETE /tutorial/" + id);

        try {
            tutorialRepository.deleteById(id);

        } catch (IllegalArgumentException e) {
            log.error("Errore durante la cancellazione del tutorial con ID: " + id, e);
        }
        return new ResponseEntity<>(HttpStatus.NO_CONTENT);
    }

    /**
     * Cancella tutti i tutorial presenti.
     *
     * @return Uno stato HTTP che indica il risultato dell'operazione.
     */
    @DeleteMapping("/tutorials")
    public ResponseEntity<HttpStatus> deleteAllTutorials() {
        log.info("Request DELETE /tutorial/");
        tutorialRepository.deleteAll();

        return new ResponseEntity<>(HttpStatus.NO_CONTENT);
    }

    // Utilizziamo Optional.ofNullable per creare Optional dei campi che potrebbero essere null
    private String validaTitolo(String titolo) {
        return Optional.ofNullable(titolo).orElseThrow(() -> new ResponseStatusException(HttpStatus.BAD_REQUEST, "Titolo non trovato"));
    }

    private String validaDescription(String descrizione) {
        return Optional.ofNullable(descrizione).orElse("");
    }

    private Boolean validaPublished(Boolean published) {
        return Optional.ofNullable(published).orElse(false);
    }
}
