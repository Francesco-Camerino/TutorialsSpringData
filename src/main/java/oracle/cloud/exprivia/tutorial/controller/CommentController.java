package oracle.cloud.exprivia.tutorial.controller;

import oracle.cloud.exprivia.tutorial.model.Comment;
import oracle.cloud.exprivia.tutorial.model.Tutorial;
import oracle.cloud.exprivia.tutorial.repository.CommentRepository;
import oracle.cloud.exprivia.tutorial.repository.TutorialRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.server.ResponseStatusException;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

/**
 * Questa classe rappresenta il controller per la gestione delle operazioni CRUD sui commenti.
 */
@RestController // This means that this class is a Controller
@RequestMapping(path="/api") // This means URL's start with /demo (after Application path)
public class CommentController {
    @Autowired // This means to get the bean called userRepository
    // Which is auto-generated by Spring, we will use it to handle the data
    private CommentRepository commentRepository;
    @Autowired
    private TutorialRepository tutorialRepository;

    Logger log = LoggerFactory.getLogger(CommentController.class);

    /**
     * Recupera tutti i commenti associati a un tutorial specificato.
     *
     * @param tutorialId L'ID del tutorial di cui recuperare i commenti.
     * @return Una ResponseEntity contenente la lista dei commenti e lo stato HTTP OK.
     * @throws ResponseStatusException Se il tutorial non viene trovato.
     */
    @GetMapping(path="/tutorials/{tutorialId}/comments")
    public ResponseEntity<Iterable<Comment>> findCommentsForATutorial(@PathVariable(value = "tutorialId") Long tutorialId) {
        log.info("REQUEST POST /tutorials/" + tutorialId + "/comments");

        if (!tutorialRepository.existsById(tutorialId)) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND,
                    "Not found Tutorial with id = " + tutorialId);
        }
        List<Comment> comments = commentRepository.findByTutorialId(tutorialId);
        return new ResponseEntity<>(comments, HttpStatus.OK);
    }

    /**
     * Recupera un commento specificato per ID.
     *
     * @param id L'ID del commento da recuperare.
     * @return Una ResponseEntity contenente il commento richiesto e lo stato HTTP OK.
     * @throws ResponseStatusException Se il commento non viene trovato.
     */
    @GetMapping(path="/comment/{id}")
    public ResponseEntity<Comment> findCommentById(@PathVariable(value = "id") Long id) {
        log.info("Request GET /comment/" + id);

        Comment commentTrovato = commentRepository.findById(id)
                .orElseThrow(()-> new ResponseStatusException(HttpStatus.NOT_FOUND, "Commento non trovato con id = " + id));
        return new ResponseEntity<>(commentTrovato, HttpStatus.OK);
    }

    /**
     * Recupera una lista di commenti che contengono il contenuto specificato.
     *
     * @param content Il contenuto da cercare nei commenti.
     * @return Una ResponseEntity contenente la lista dei commenti che contengono il contenuto
     *         e lo stato HTTP OK, oppure uno stato HTTP NO_CONTENT se nessun commento è trovato.
     */
    @GetMapping(path="/comment/getByContent")
    public ResponseEntity<List<Comment>> findByContentContaining(@RequestParam(name = "content") String content) {
        log.info("Request GET /comment/getByContent" + content);

        List<Comment> comments = new ArrayList<Comment>(commentRepository.findByContentContaining(content));

        if (comments.isEmpty()) {
            // Nessun contenuto da ritornare
            return new ResponseEntity<>(HttpStatus.NO_CONTENT);
        }

        return new ResponseEntity<>(comments, HttpStatus.OK);
    }

    /**
     * Aggiunge un nuovo commento associato a un tutorial specificato.
     *
     * @param tutorialId     L'ID del tutorial a cui aggiungere il commento.
     * @param commentRequest L'oggetto Comment contenente il nuovo commento.
     * @return Una ResponseEntity contenente il nuovo commento aggiunto e lo stato HTTP CREATED.
     * @throws ResponseStatusException Se il tutorial non viene trovato.
     */
    @PostMapping(path="/tutorials/{tutorialId}/comments")
    public ResponseEntity<Comment> addCommentForATutorial (@PathVariable(value = "tutorialId") Long tutorialId,
                                                           @RequestBody Comment commentRequest) {
        log.info("REQUEST POST /tutorials/" + tutorialId + "/comments");

        Comment commentNuovo = tutorialRepository.findById(tutorialId).map(t -> {
           String content = Optional.ofNullable(commentRequest.getContent()).orElse("");
            commentRequest.setTutorial(t);
            commentRequest.setContent(content);
            return commentRepository.save(commentRequest);
        }).orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Tutorial non trovato con id = " + tutorialId));

        return new ResponseEntity<>(commentNuovo, HttpStatus.CREATED);
    }

    /**
     * Aggiorna un commento specificato per ID.
     *
     * @param id              L'ID del commento da aggiornare.
     * @param commentRequest L'oggetto Comment contenente il commento aggiornato.
     * @return Una ResponseEntity contenente il commento aggiornato e lo stato HTTP OK.
     * @throws ResponseStatusException Se il commento non viene trovato.
     */
    @PutMapping("/comment/{id}")
    public ResponseEntity<Comment> updateComment(@PathVariable("id") Long id, @RequestBody Comment commentRequest) {
        log.info("Request PUT /comment/" + id);

        Comment commentDaAggiornare = commentRepository.findById(id)
                .orElseThrow( ()-> new ResponseStatusException(HttpStatus.NOT_FOUND, "Comment non trovato con id " + id));

        String content = Optional.ofNullable(commentRequest.getContent()).orElse("");
        commentDaAggiornare.setContent(content);

        return new ResponseEntity<>(commentRepository.save(commentDaAggiornare),HttpStatus.OK);
    }

    /**
     * Elimina un commento specificato per ID.
     *
     * @param id L'ID del commento da eliminare.
     * @return Una ResponseEntity con stato HTTP NO_CONTENT.
     */
    @DeleteMapping(path="/comment/{id}")
    public ResponseEntity<HttpStatus> deleteCommentById(@PathVariable("id") Long id) {
        log.info("Request DELETE /comment/" + id);

        try {
            commentRepository.deleteById(id);

        } catch (IllegalArgumentException e) {
            log.error("Errore durante la cancellazione del comment con ID: " + id, e);
        }
        return new ResponseEntity<>(HttpStatus.NO_CONTENT);
    }

    /**
     * Elimina tutti i commenti associati a un tutorial specificato.
     *
     * @param tutorialId L'ID del tutorial di cui eliminare i commenti.
     * @return Una ResponseEntity con stato HTTP NO_CONTENT.
     * @throws ResponseStatusException Se il tutorial non viene trovato.
     */
    @DeleteMapping("/tutorials/{tutorialId}/comments")
    public ResponseEntity<List<Comment>> deleteAllCommentsOfTutorial(@PathVariable(value = "tutorialId") Long tutorialId) {
        log.info("REQUEST DELETE /tutorials/" + tutorialId + "/comments");

        if (!tutorialRepository.existsById(tutorialId)) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND,
                    "Not found Tutorial with id = " + tutorialId);
        }

        // Spring data jpa riesce a capire che deve prendere il tutorial e di esso il suo id grazie alla relazione 1 a n che c'è fra Tutorial e Comment
        commentRepository.deleteByTutorialId(tutorialId);
        return new ResponseEntity<>(HttpStatus.NO_CONTENT);
    }

}
